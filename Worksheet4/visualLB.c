#include "visualLB.h"
#include <stdio.h>
#include "LBDefinitions.h"
#include "helper.h"
#include "computeCellValues.h"


void writeVtkOutput(const double * const collideField, const int * const flagField, const char * filename, int rank, unsigned int t, int *subdomain, int *xlength, int *proc) {

    char fn[120];

    // save filename as a combination of passed filename and timestep
    sprintf(fn, "%s_%i.%i.vtk", filename, rank, t);

    FILE *fp = NULL;
    fp = fopen(fn, "w");
    if (fp == NULL) {
        ERROR("Failed to open file!");
        return;
    }

    // write header
    fprintf(fp, "# vtk DataFile Version 2.0\n");
    fprintf(fp, "generated by CFD-lab course output \n");
    fprintf(fp, "ASCII\n\n");
    fprintf(fp, "DATASET STRUCTURED_GRID\n");
    fprintf(fp, "DIMENSIONS %d %d %d \n", subdomain[0], subdomain[1], subdomain[2]);
    fprintf(fp, "POINTS %d float\n\n", (subdomain[0]) * (subdomain[1]) * (subdomain[2]));

    // print lattice points
    double stepx = 1.0 / (xlength[0] - 1);
    double stepy = 1.0 / (xlength[1] - 1);
    double stepz = 1.0 / (xlength[2] - 1);

    int startx = (rank%proc[0]) * subdomain[0];
    int starty = ((rank%(proc[0]*proc[1])) / proc[0]) * subdomain[1];
    int startz = (rank/(proc[0]*proc[1])) * subdomain[2];

    for (double x = 0; x <= subdomain[0]-1; x+=1) {			// (x = startx*subdomain[0]*stepx; x < startx*(subdomain[0]+1)*stepx;)
        for (double y = 0; y <= subdomain[1]-1; y+=1) {			// (y = starty*subdomain[1]*stepy; y <= starty*(subdomain[1]+1)*stepy;)
            for (double z = 0; z <= subdomain[2]-1; z+=1) {		// ...
                fprintf(fp, "%f %f %f\n", (startx + x)*stepx, (starty + y)*stepy, (startz + z)*stepz);
            }
        }
    }

    double density;
    double vel[D];
    const double *currentCell;

    // write density data
    fprintf(fp, "\nPOINT_DATA %d \n", (subdomain[0]) * (subdomain[1]) * (subdomain[2]));
    fprintf(fp, "SCALARS density float 1 \n");
    fprintf(fp, "LOOKUP_TABLE default \n");
    
    for (int x = 1; x < subdomain[0]+1; ++x) {
        for (int y = 1; y < subdomain[1]+1; ++y) {
            for (int z = 1; z < subdomain[2]+1; ++z) {
                currentCell = collideField + Q*(compute_index(x, y, z, subdomain));
                computeDensity(currentCell, &density);
                fprintf(fp, "%f\n", density);
            }
        }
    }

    // compute velocities for all cells
    fprintf(fp, "\nVECTORS velocity float\n");
    
    for (int x = 1; x < subdomain[0]+1; ++x) {
        for (int y = 1; y < subdomain[1]+1; ++y) {
            for (int z = 1; z < subdomain[2]+1; ++z) {
                currentCell = collideField + Q*(compute_index(x, y, z, subdomain));
                computeDensity(currentCell, &density);
                computeVelocity(currentCell, &density, vel);
                fprintf(fp, "%f %f %f\n", vel[0], vel[1], vel[2]);
            }
        }
    }

    // close the file
    if (fclose(fp)) {
        ERROR("Failed to close file!");
        return;
    }
}

